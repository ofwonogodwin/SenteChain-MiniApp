import { useState, useEffect } from 'react';
import {
  getUserBalance,
  getSavingsBalance,
  getUnlockTime,
  claimFaucet,
  canClaimFaucet,
  switchToBaseSepolia
} from '../utils/contract';
import toast from 'react-hot-toast';

export default function WalletCard({ userAddress, onBalanceUpdate }) {
  const [balance, setBalance] = useState('0');
  const [savingsBalance, setSavingsBalance] = useState('0');
  const [unlockTime, setUnlockTime] = useState(0);
  const [loading, setLoading] = useState(true);
  const [claiming, setClaiming] = useState(false);
  const [isMetaMaskInstalled, setIsMetaMaskInstalled] = useState(true);
  const [isMetaMaskInstalled, setIsMetaMaskInstalled] = useState(true);

  // Check for MetaMask installation
  useEffect(() => {
    setIsMetaMaskInstalled(!!window.ethereum);
  }, []);

  // Check for MetaMask installation
  useEffect(() => {
    setIsMetaMaskInstalled(!!window.ethereum);
  }, []);

  // Load balances initially and set up auto-refresh
  useEffect(() => {
    if (userAddress && isMetaMaskInstalled) {
      loadBalances();

      // Set up automatic refresh every 10 seconds
      const refreshInterval = setInterval(loadBalances, 10000);

      // Listen for network changes
      if (window.ethereum) {
        window.ethereum.on('chainChanged', loadBalances);
        window.ethereum.on('accountsChanged', loadBalances);
      }

      // Cleanup
      return () => {
        clearInterval(refreshInterval);
        if (window.ethereum) {
          window.ethereum.removeListener('chainChanged', loadBalances);
          window.ethereum.removeListener('accountsChanged', loadBalances);
        }
      };
    }
  }, [userAddress]);

  const loadBalances = async () => {
    try {
      // Only show loading on initial load
      if (balance === '0') {
        setLoading(true);
      }

      // Validate connection first
      if (!window.ethereum) {
        throw new Error('Please install MetaMask');
      }

      // Check if connected to correct network
      const chainId = await window.ethereum.request({ method: 'eth_chainId' });
      if (chainId !== '0x14A34') { // Base Sepolia
        toast.loading('Switching to Base Sepolia network...');
        try {
          await switchToBaseSepolia();
          toast.dismiss();
          toast.success('Successfully switched to Base Sepolia!');
          // Wait a moment for the network to fully switch
          await new Promise(resolve => setTimeout(resolve, 1000));
          // Return early - the chainChanged event will trigger a reload
          return;
        } catch (switchError) {
          toast.dismiss();
          console.error('Network switch error:', switchError);

          // Provide more helpful error messages
          if (switchError.code === 4001) {
            toast.error('Please approve the network switch in MetaMask');
          } else if (switchError.message?.includes('User rejected')) {
            toast.error('Network switch cancelled. Please switch to Base Sepolia manually.');
          } else {
            toast.error('Please switch to Base Sepolia network in MetaMask');
          }

          // Don't throw error, just return to prevent further execution
          return;
        }
      }

      // Get all balances in parallel
      const [bal, savBal, unlock] = await Promise.all([
        getUserBalance(userAddress),
        getSavingsBalance(userAddress),
        getUnlockTime(userAddress),
      ]);

      // Update state only if component is still mounted and values have changed
      setBalance(prevBal => prevBal !== bal ? bal : prevBal);
      setSavingsBalance(prevSavBal => prevSavBal !== savBal ? savBal : prevSavBal);
      setUnlockTime(prevUnlock => prevUnlock !== unlock ? unlock : prevUnlock);

      if (onBalanceUpdate) {
        onBalanceUpdate(bal, savBal);
      }
    } catch (error) {
      console.error('Error loading balances:', error);

      // Don't show error toast for network-related issues (already handled above)
      if (!error.message?.includes('switch') && !error.message?.includes('network')) {
        toast.error(error.message || 'Failed to load balances');
      }
    } finally {
      setLoading(false);
    }
  };

  const handleClaimFaucet = async () => {
    try {
      setClaiming(true);

      // Check if user can claim
      const canClaim = await canClaimFaucet(userAddress);
      if (!canClaim) {
        toast.error('Please wait 24 hours between claims');
        setClaiming(false);
        return;
      }

      toast.loading('Claiming 100 sUSDT from faucet...');

      const tx = await claimFaucet();

      toast.dismiss();
      toast.success(`Claimed 100 sUSDT! ðŸŽ‰ TX: ${tx.hash.slice(0, 10)}...`);

      // Reload balances
      setTimeout(() => loadBalances(), 2000);
    } catch (error) {
      toast.dismiss();
      const errorMsg = error.message || error.reason || 'Unknown error';
      if (errorMsg.includes('24 hours')) {
        toast.error('Please wait 24 hours between claims');
      } else {
        toast.error('Failed to claim tokens: ' + errorMsg);
      }
      console.error('Faucet error:', error);
    } finally {
      setClaiming(false);
    }
  };

  const formatDate = (timestamp) => {
    if (!timestamp || timestamp === 0) return 'N/A';
    return new Date(timestamp * 1000).toLocaleDateString();
  };

  const isLocked = unlockTime > Date.now() / 1000;

  return (
    <div className="card">
      {!isMetaMaskInstalled ? (
        <div className="text-center py-6">
          <h3 className="text-xl font-bold text-gray-800 mb-4">MetaMask Required</h3>
          <p className="text-gray-600 mb-4">To use this application, you need to install MetaMask.</p>
          <a
            href="https://metamask.io/download/"
            target="_blank"
            rel="noopener noreferrer"
            className="btn-primary inline-block"
          >
            Install MetaMask
          </a>
        </div>
      ) : (
        <>
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-bold text-gray-800">My Wallet</h2>
            <button
              onClick={loadBalances}
              disabled={loading}
              className="text-primary hover:text-primary-dark"
            >
              {loading ? 'Loading...' : 'Refresh'}
            </button>
          </div>

      {/* Available Balance */}
      <div className="bg-gradient-to-r from-primary to-primary-dark rounded-lg p-6 mb-4 text-white">
        <p className="text-sm opacity-90 mb-1">Available Balance</p>
        <p className="text-4xl font-bold mb-2">
          {loading ? '...' : parseFloat(balance).toFixed(2)} sUSDT
        </p>
        <p className="text-xs opacity-75">â‰ˆ ${loading ? '...' : parseFloat(balance).toFixed(2)} USD</p>
      </div>

      {/* Savings Balance */}
      <div className="bg-gradient-to-r from-accent to-yellow-500 rounded-lg p-4 mb-4 text-white">
        <div className="flex justify-between items-center">
          <div>
            <p className="text-xs opacity-90 mb-1">Savings Vault</p>
            <p className="text-2xl font-bold">
              {loading ? '...' : parseFloat(savingsBalance).toFixed(2)} sUSDT
            </p>
          </div>
          <div className="text-right">
            <p className="text-xs opacity-90">Unlock Date</p>
            <p className="text-sm font-semibold">{formatDate(unlockTime)}</p>
            {isLocked && (
              <span className="text-xs bg-white bg-opacity-20 px-2 py-1 rounded mt-1 inline-block">
                Locked
              </span>
            )}
          </div>
        </div>
      </div>

      {/* Faucet Button */}
      <button
        onClick={handleClaimFaucet}
        disabled={claiming || loading}
        className="w-full btn-secondary text-sm"
      >
        {claiming ? 'Claiming...' : 'Claim 100 sUSDT (Testnet Faucet)'}
      </button>
    </div>
        </>
      )}
    </div>
  );
}
